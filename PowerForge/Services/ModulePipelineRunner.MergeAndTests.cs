using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Text;
using System.Text.Json;

namespace PowerForge;

public sealed partial class ModulePipelineRunner
{
    private bool ApplyMerge(ModulePipelinePlan plan, ModuleBuildResult buildResult)
    {
        if (plan is null || buildResult is null) return false;
        if (!plan.MergeModule && !plan.MergeMissing) return false;

        var mergeInfo = BuildMergeSources(buildResult.StagingPath, plan.ModuleName, plan.Information, buildResult.Exports);
        if (!mergeInfo.HasScripts && !File.Exists(mergeInfo.Psm1Path))
        {
            _logger.Warn("Merge requested but no script sources or PSM1 file were found.");
            return false;
        }

        string? analysisCode = mergeInfo.HasScripts ? mergeInfo.MergedScriptContent : null;
        string? analysisPath = mergeInfo.HasScripts ? null : mergeInfo.Psm1Path;

        MissingFunctionsReport? missingReport = null;
        string[] dependentRequiredModules = Array.Empty<string>();
        if (plan.MergeModule || plan.MergeMissing)
        {
            var requiredModules = GetRequiredModuleNames(plan);
            var approvedModules = plan.ApprovedModules ?? Array.Empty<string>();
            dependentRequiredModules = ResolveDependentRequiredModules(requiredModules, approvedModules);

            missingReport = AnalyzeMissingFunctions(analysisPath, analysisCode, plan);
            LogMergeSummary(plan, mergeInfo, missingReport, dependentRequiredModules);
            if (missingReport is not null)
                ValidateMissingFunctions(missingReport, plan, dependentRequiredModules);
        }

        var mergedModule = false;
        if (plan.MergeModule)
        {
            if (mergeInfo.HasLib)
            {
                _logger.Warn("MergeModuleOnBuild requested but binary outputs were detected. Keeping bootstrapper PSM1.");
            }
            else if (!mergeInfo.HasScripts)
            {
                _logger.Warn("MergeModuleOnBuild requested but no script sources were found. Skipping merge.");
            }
            else
            {
                if (File.Exists(mergeInfo.Psm1Path))
                {
                    try
                    {
                        var existing = File.ReadAllText(mergeInfo.Psm1Path);    
                        if (!string.IsNullOrWhiteSpace(existing) && !IsAutoGeneratedPsm1(existing))
                            _logger.Warn("MergeModuleOnBuild will overwrite existing PSM1 content in staging.");
                    }
                    catch
                    {
                        // best effort only
                    }
                }

                var merged = mergeInfo.MergedScriptContent;
                if (plan.MergeMissing && missingReport?.Functions is { Length: > 0 })
                    merged = PrependFunctions(missingReport.Functions, merged);

                WriteMergedPsm1(mergeInfo.Psm1Path, merged);
                mergedModule = true;
            }
        }

        if (!mergedModule && plan.MergeMissing && missingReport?.Functions is { Length: > 0 } && File.Exists(mergeInfo.Psm1Path))
        {
            var existing = File.ReadAllText(mergeInfo.Psm1Path);
            var merged = PrependFunctions(missingReport.Functions, existing);
            WriteMergedPsm1(mergeInfo.Psm1Path, merged);
        }

        return mergedModule;
    }

    private void ApplyPlaceholders(ModulePipelinePlan plan, ModuleBuildResult buildResult)
    {
        if (plan is null || buildResult is null) return;

        var psm1Path = Path.Combine(buildResult.StagingPath, $"{plan.ModuleName}.psm1");
        if (!File.Exists(psm1Path)) return;

        var moduleName = plan.ModuleName;
        var moduleVersion = plan.ResolvedVersion;
        var preRelease = plan.PreRelease;
        var moduleVersionWithPreRelease = string.IsNullOrWhiteSpace(preRelease)
            ? moduleVersion
            : $"{moduleVersion}-{preRelease}";
        var tagName = "v" + moduleVersion;
        var tagModuleVersionWithPreRelease = "v" + moduleVersionWithPreRelease;

        var replacements = new List<(string Find, string Replace)>();
        if (plan.PlaceHolderOption?.SkipBuiltinReplacements != true)
        {
            replacements.Add(("{ModuleName}", moduleName));
            replacements.Add(("<ModuleName>", moduleName));
            replacements.Add(("{ModuleVersion}", moduleVersion));
            replacements.Add(("<ModuleVersion>", moduleVersion));
            replacements.Add(("{ModuleVersionWithPreRelease}", moduleVersionWithPreRelease));
            replacements.Add(("<ModuleVersionWithPreRelease>", moduleVersionWithPreRelease));
            replacements.Add(("{TagModuleVersionWithPreRelease}", tagModuleVersionWithPreRelease));
            replacements.Add(("<TagModuleVersionWithPreRelease>", tagModuleVersionWithPreRelease));
            replacements.Add(("{TagName}", tagName));
            replacements.Add(("<TagName>", tagName));
        }

        if (plan.PlaceHolders is { Length: > 0 })
        {
            foreach (var entry in plan.PlaceHolders)
            {
                if (entry is null) continue;
                if (string.IsNullOrWhiteSpace(entry.Find)) continue;
                replacements.Add((entry.Find, entry.Replace ?? string.Empty));
            }
        }

        if (replacements.Count == 0) return;

        string content;
        try { content = File.ReadAllText(psm1Path); }
        catch (Exception ex)
        {
            _logger.Warn($"Failed to read PSM1 for placeholder replacement: {ex.Message}");
            return;
        }

        var updated = content;
        foreach (var item in replacements)
        {
            if (string.IsNullOrEmpty(item.Find)) continue;
            updated = updated.Replace(item.Find, item.Replace ?? string.Empty);
        }

        if (string.Equals(content, updated, StringComparison.Ordinal)) return;

        try
        {
            File.WriteAllText(psm1Path, updated, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));
        }
        catch (Exception ex)
        {
            _logger.Warn($"Failed to write PSM1 after placeholder replacement: {ex.Message}");
        }
    }

    private void RunImportModules(ModulePipelinePlan plan, ModuleBuildResult buildResult)
    {
        var cfg = plan.ImportModules;
        if (cfg is null) return;

        var importSelf = cfg.Self == true;
        var importRequired = cfg.RequiredModules == true;
        if (!importSelf && !importRequired) return;

        var modules = importRequired
            ? plan.RequiredModules
                .Where(m => !string.IsNullOrWhiteSpace(m.ModuleName))
                .Select(m => new ImportModuleEntry
                {
                    Name = m.ModuleName.Trim(),
                    MinimumVersion = string.IsNullOrWhiteSpace(m.ModuleVersion) ? null : m.ModuleVersion!.Trim(),
                    RequiredVersion = string.IsNullOrWhiteSpace(m.RequiredVersion) ? null : m.RequiredVersion!.Trim()
                })
                .ToArray()
            : Array.Empty<ImportModuleEntry>();

        var modulesB64 = EncodeImportModules(modules);
        var args = new List<string>(5)
        {
            modulesB64,
            importRequired ? "1" : "0",
            importSelf ? "1" : "0",
            buildResult.ManifestPath,
            cfg.Verbose == true ? "1" : "0"
        };

        var runner = new PowerShellRunner();
        var script = BuildImportModulesScript();
        var result = RunScript(runner, script, args, TimeSpan.FromMinutes(5));
        if (result.ExitCode != 0)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"Import-Module failed (exit {result.ExitCode}).");
            if (!string.IsNullOrWhiteSpace(result.StdOut))
            {
                sb.AppendLine("StdOut:");
                sb.AppendLine(result.StdOut.TrimEnd());
            }
            if (!string.IsNullOrWhiteSpace(result.StdErr))
            {
                sb.AppendLine("StdErr:");
                sb.AppendLine(result.StdErr.TrimEnd());
            }
            throw new InvalidOperationException(sb.ToString().TrimEnd());
        }
    }

    private void RunTestsAfterMerge(
        ModulePipelinePlan plan,
        ModuleBuildResult buildResult,
        TestConfiguration testConfiguration,
        ModuleTestSuiteService service)
    {
        if (plan is null || buildResult is null || testConfiguration is null) return;

        var testsPath = testConfiguration.TestsPath ?? string.Empty;
        if (string.IsNullOrWhiteSpace(testsPath))
            throw new InvalidOperationException("TestsAfterMerge is enabled but TestsPath is empty.");

        if (!Path.IsPathRooted(testsPath))
            testsPath = Path.GetFullPath(Path.Combine(plan.ProjectRoot, testsPath));

        var importCfg = plan.ImportModules;
        var importSelf = importCfg?.Self == true;
        var importRequired = importCfg?.RequiredModules == true;
        var importVerbose = importCfg?.Verbose == true;

        var importModules = importRequired
            ? plan.RequiredModules
                .Where(m => !string.IsNullOrWhiteSpace(m.ModuleName))
                .Select(m => new ModuleDependency(
                    name: m.ModuleName.Trim(),
                    requiredVersion: m.RequiredVersion,
                    minimumVersion: m.ModuleVersion,
                    maximumVersion: m.MaximumVersion))
                .ToArray()
            : Array.Empty<ModuleDependency>();

        var spec = new ModuleTestSuiteSpec
        {
            ProjectPath = buildResult.StagingPath,
            TestPath = testsPath,
            Force = testConfiguration.Force,
            SkipDependencies = true,
            SkipImport = !importSelf,
            ImportModules = importModules,
            ImportModulesVerbose = importVerbose
        };

        var result = service.Run(spec);
        if (result.FailedCount > 0)
        {
            if (testConfiguration.Force)
            {
                _logger.Warn($"TestsAfterMerge failed ({result.FailedCount} failed) but Force was set; continuing.");
            }
            else
            {
                throw new InvalidOperationException($"TestsAfterMerge failed ({result.FailedCount} failed).");
            }
        }
    }

    private static string BuildImportModulesScript()
    {
        return EmbeddedScripts.Load("Scripts/ModulePipeline/Import-Modules.ps1");
    }

    private static string EncodeImportModules(IEnumerable<ImportModuleEntry> modules)
    {
        var list = modules?.Where(m => m is not null && !string.IsNullOrWhiteSpace(m.Name)).ToArray() ?? Array.Empty<ImportModuleEntry>();
        if (list.Length == 0) return string.Empty;
        var json = JsonSerializer.Serialize(list);
        return Convert.ToBase64String(Encoding.UTF8.GetBytes(json));
    }

    private sealed class ImportModuleEntry
    {
        public string Name { get; set; } = string.Empty;
        public string? MinimumVersion { get; set; }
        public string? RequiredVersion { get; set; }
    }


    private static MergeSourceInfo BuildMergeSources(string rootPath, string moduleName, InformationConfiguration? information, ExportSet exports)
    {
        var root = Path.GetFullPath(rootPath);
        var psm1 = Path.Combine(root, $"{moduleName}.psm1");

        var dirs = ResolveMergeDirectories(information);
        var files = new List<string>();
        foreach (var dir in dirs)
        {
            if (string.IsNullOrWhiteSpace(dir)) continue;
            var full = Path.Combine(root, dir);
            if (!Directory.Exists(full)) continue;
            try
            {
                files.AddRange(Directory.EnumerateFiles(full, "*.ps1", SearchOption.AllDirectories));
            }
            catch
            {
                // best effort only
            }
        }

        var ordered = files
            .Where(f => !string.IsNullOrWhiteSpace(f))
            .Select(Path.GetFullPath)
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .OrderBy(f => f, StringComparer.OrdinalIgnoreCase)
            .ToArray();

        var merged = ordered.Length > 0 ? BuildMergedScriptContent(root, ordered, exports) : string.Empty;
        var libRoot = Path.Combine(root, "Lib");
        var hasLib = Directory.Exists(libRoot) && Directory.EnumerateDirectories(libRoot).Any();

        return new MergeSourceInfo(psm1, ordered, merged, hasLib);
    }

    private static string[] ResolveMergeDirectories(InformationConfiguration? information)
    {
        var ordered = new List<string> { "Classes", "Enums", "Private", "Public" };

        if (information?.IncludePS1 is { Length: > 0 })
        {
            foreach (var entry in information.IncludePS1)
            {
                if (string.IsNullOrWhiteSpace(entry)) continue;
                if (ordered.Any(o => string.Equals(o, entry, StringComparison.OrdinalIgnoreCase))) continue;
                ordered.Add(entry);
            }
        }

        return ordered.ToArray();
    }

    private static string BuildMergedScriptContent(string rootPath, IReadOnlyList<string> files, ExportSet exports)
    {
        var requires = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var usingLines = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var body = new StringBuilder(8192);

        foreach (var file in files)
        {
            if (string.IsNullOrWhiteSpace(file) || !File.Exists(file)) continue;

            string[] lines;
            try { lines = File.ReadAllLines(file); }
            catch { continue; }

            var block = new List<string>();

            foreach (var line in lines)
            {
                var trimmed = line.TrimStart();
                if (trimmed.StartsWith("#requires", StringComparison.OrdinalIgnoreCase))
                {
                    requires.Add(trimmed);
                    continue;
                }
                if (trimmed.StartsWith("using ", StringComparison.OrdinalIgnoreCase))
                {
                    usingLines.Add(trimmed);
                    continue;
                }
                block.Add(line);
            }

            if (block.Count == 0) continue;

            foreach (var line in block) body.AppendLine(line);
            body.AppendLine();
        }

        var header = new StringBuilder(1024);
        foreach (var req in requires.OrderBy(r => r, StringComparer.OrdinalIgnoreCase))
            header.AppendLine(req);
        foreach (var use in usingLines.OrderBy(r => r, StringComparer.OrdinalIgnoreCase))
            header.AppendLine(use);

        if (header.Length > 0)
            header.AppendLine();

        header.Append(body.ToString().TrimEnd());

        var merged = header.ToString().TrimEnd();
        var exportBlock = BuildExportBlock(exports);
        if (!string.IsNullOrWhiteSpace(exportBlock))
        {
            if (!string.IsNullOrWhiteSpace(merged))
                merged += Environment.NewLine + Environment.NewLine;
            merged += exportBlock.TrimEnd();
        }

        return merged;
    }

    private static string BuildExportBlock(ExportSet exports)
    {
        var sb = new StringBuilder(256);
        sb.AppendLine("$FunctionsToExport = " + FormatPsStringList(exports.Functions));
        sb.AppendLine("$CmdletsToExport = " + FormatPsStringList(exports.Cmdlets));
        sb.AppendLine("$AliasesToExport = " + FormatPsStringList(exports.Aliases));
        sb.AppendLine("Export-ModuleMember -Function $FunctionsToExport -Alias $AliasesToExport -Cmdlet $CmdletsToExport");
        return sb.ToString();
    }

    private static string FormatPsStringList(IReadOnlyList<string>? values)
    {
        var list = (values ?? Array.Empty<string>())
            .Where(v => !string.IsNullOrWhiteSpace(v))
            .Select(v => v.Trim())
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToArray();

        if (list.Length == 0) return "@()";

        var sb = new StringBuilder();
        sb.Append("@(");
        for (var i = 0; i < list.Length; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append('\'').Append(EscapePsSingleQuoted(list[i])).Append('\'');
        }
        sb.Append(')');
        return sb.ToString();
    }

    private static string EscapePsSingleQuoted(string value)
        => value?.Replace("'", "''") ?? string.Empty;

    private void TryRegenerateBootstrapperFromManifest(ModuleBuildResult buildResult, string moduleName, IReadOnlyList<string>? exportAssemblies)
    {
        try
        {
            var exports = ReadExportsFromManifest(buildResult.ManifestPath);
            ModuleBootstrapperGenerator.Generate(buildResult.StagingPath, moduleName, exports, exportAssemblies);
        }
        catch (Exception ex)
        {
            _logger.Warn($"Failed to regenerate module bootstrapper exports for '{moduleName}'. Error: {ex.Message}");
            if (_logger.IsVerbose) _logger.Verbose(ex.ToString());
        }
    }

    private static ExportSet ReadExportsFromManifest(string psd1Path)
        => new(ReadStringOrArray(psd1Path, "FunctionsToExport"),
            ReadStringOrArray(psd1Path, "CmdletsToExport"),
            ReadStringOrArray(psd1Path, "AliasesToExport"));

    private static string[] ReadStringOrArray(string psd1Path, string key)
    {
        if (ManifestEditor.TryGetTopLevelStringArray(psd1Path, key, out var values) && values is not null)
            return values;
        if (ManifestEditor.TryGetTopLevelString(psd1Path, key, out var value) && !string.IsNullOrWhiteSpace(value))
            return new[] { value! };
        return Array.Empty<string>();
    }

    private static string PrependFunctions(string[] functions, string content)
    {
        var block = (functions ?? Array.Empty<string>())
            .Where(f => !string.IsNullOrWhiteSpace(f))
            .ToArray();
        if (block.Length == 0) return content;

        var prefix = string.Join(Environment.NewLine, block);
        return string.IsNullOrWhiteSpace(content)
            ? prefix
            : prefix + Environment.NewLine + Environment.NewLine + content;
    }

    private static void WriteMergedPsm1(string path, string content)
    {
        var normalized = NormalizeCrLf(content);
        File.WriteAllText(path, normalized, new UTF8Encoding(encoderShouldEmitUTF8Identifier: true));
    }

    private static bool IsAutoGeneratedPsm1(string content)
        => !string.IsNullOrWhiteSpace(content) &&
           content.IndexOf("Auto-generated by PowerForge", StringComparison.OrdinalIgnoreCase) >= 0;

    private static string NormalizeCrLf(string text)
        => string.IsNullOrEmpty(text)
            ? string.Empty
            : text.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n");

}
