using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace PowerForge;

internal static class ModuleBootstrapperGenerator
{
    private static readonly UTF8Encoding Utf8Bom = new(encoderShouldEmitUTF8Identifier: true);

    internal static void Generate(string moduleRoot, string moduleName, ExportSet exports, IReadOnlyList<string>? exportAssemblies)
    {
        if (string.IsNullOrWhiteSpace(moduleRoot)) throw new ArgumentException("Module root is required.", nameof(moduleRoot));
        if (string.IsNullOrWhiteSpace(moduleName)) throw new ArgumentException("Module name is required.", nameof(moduleName));

        var root = Path.GetFullPath(moduleRoot);
        if (!Directory.Exists(root)) throw new DirectoryNotFoundException($"Module root not found: {root}");

        var hasScriptFolders = HasAnyDirectory(root, "Public", "Private", "Classes", "Enums");
        var libRoot = Path.Combine(root, "Lib");
        var hasLib = Directory.Exists(libRoot) && Directory.EnumerateDirectories(libRoot).Any();

        // Avoid overwriting "single file" script modules that keep all code in the PSM1 and do not use folder layout.
        // If there is no Lib and no folder-based layout, leave the existing PSM1 intact.
        if (!hasLib && !hasScriptFolders) return;

        var exportAssemblyFileNames = ResolveExportAssemblyFileNames(moduleName, exportAssemblies);
        var primaryAssemblyName = exportAssemblyFileNames.FirstOrDefault() ?? (moduleName + ".dll");
        var primaryLibraryName = Path.GetFileNameWithoutExtension(primaryAssemblyName);
        if (string.IsNullOrWhiteSpace(primaryLibraryName)) primaryLibraryName = moduleName;

        if (hasLib)
        {
            var librariesPath = Path.Combine(root, $"{moduleName}.Libraries.ps1");
            var librariesContent = BuildLibrariesScript(root, moduleName, exportAssemblyFileNames);
            WritePowerShellFile(librariesPath, librariesContent);
        }

        var psm1Path = Path.Combine(root, $"{moduleName}.psm1");
        var psm1Content = BuildBootstrapperPsm1(moduleName, primaryLibraryName, exports, includeBinaryLoader: hasLib);
        WritePowerShellFile(psm1Path, psm1Content);
    }

    private static bool HasAnyDirectory(string root, params string[] directoryNames)
        => (directoryNames ?? Array.Empty<string>())
            .Where(d => !string.IsNullOrWhiteSpace(d))
            .Any(d => Directory.Exists(Path.Combine(root, d)));

    private static string[] ResolveExportAssemblyFileNames(string moduleName, IReadOnlyList<string>? exportAssemblies)
    {
        var fileNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        var specified = (exportAssemblies ?? Array.Empty<string>())
            .Where(s => !string.IsNullOrWhiteSpace(s))
            .Select(s => s.Trim().Trim('"'))
            .ToArray();

        var entries = specified.Length > 0 ? specified : new[] { moduleName + ".dll" };
        foreach (var entry in entries)
        {
            if (string.IsNullOrWhiteSpace(entry)) continue;
            var name = entry.EndsWith(".dll", StringComparison.OrdinalIgnoreCase) ? entry : entry + ".dll";
            name = Path.GetFileName(name);
            if (string.IsNullOrWhiteSpace(name)) continue;
            fileNames.Add(name);
        }

        return fileNames.ToArray();
    }

    private static void WritePowerShellFile(string path, string content)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(path)!);
        File.WriteAllText(path, NormalizeCrLf(content), Utf8Bom);
    }

    private static string NormalizeCrLf(string text)
    {
        if (string.IsNullOrEmpty(text)) return string.Empty;
        // Ensure deterministic CRLF output for Windows PowerShell.
        return text.Replace("\r\n", "\n").Replace("\r", "\n").Replace("\n", "\r\n");
    }

    private static string BuildLibrariesScript(string moduleRoot, string moduleName, IReadOnlyList<string> exportAssemblyFileNames)
    {
        // Generate a deterministic list of DLLs to Add-Type for each Lib/<Folder>.
        var libRoot = Path.Combine(moduleRoot, "Lib");
        var byFolder = new Dictionary<string, List<string>>(StringComparer.OrdinalIgnoreCase)
        {
            ["Core"] = EnumerateDllRelativePaths(libRoot, "Core", exportAssemblyFileNames),
            ["Default"] = EnumerateDllRelativePaths(libRoot, "Default", exportAssemblyFileNames),
            ["Standard"] = EnumerateDllRelativePaths(libRoot, "Standard", exportAssemblyFileNames),
            [""] = EnumerateDllRelativePaths(libRoot, null, exportAssemblyFileNames),
        };

        var sb = new StringBuilder(4096);
        sb.AppendLine($"# {moduleName}.Libraries.ps1");
        sb.AppendLine("# Auto-generated by PowerForge. Do not edit.");
        sb.AppendLine();
        sb.AppendLine("$LibrariesByFolder = @{");

        foreach (var key in new[] { "Core", "Default", "Standard", "" })
        {
            byFolder.TryGetValue(key, out var list);
            list ??= new List<string>();

            sb.Append("    ");
            sb.Append('\'').Append(EscapePsSingleQuoted(key)).Append('\'');
            sb.Append(" = @(").AppendLine();

            foreach (var rel in list)
                sb.Append("        '").Append(EscapePsSingleQuoted(rel)).AppendLine("'");

            sb.AppendLine("    )");
        }

        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("$AssemblyFolders = Get-ChildItem -Path $PSScriptRoot\\Lib -Directory -ErrorAction SilentlyContinue");
        sb.AppendLine();
        sb.AppendLine("$Default = $false");
        sb.AppendLine("$Core = $false");
        sb.AppendLine("$Standard = $false");
        sb.AppendLine("foreach ($A in $AssemblyFolders.Name) {");
        sb.AppendLine("    if ($A -eq 'Default') {");
        sb.AppendLine("        $Default = $true");
        sb.AppendLine("    } elseif ($A -eq 'Core') {");
        sb.AppendLine("        $Core = $true");
        sb.AppendLine("    } elseif ($A -eq 'Standard') {");
        sb.AppendLine("        $Standard = $true");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine("if ($Standard -and $Core -and $Default) {");
        sb.AppendLine("    $FrameworkNet = 'Default'");
        sb.AppendLine("    $Framework = 'Standard'");
        sb.AppendLine("} elseif ($Standard -and $Core) {");
        sb.AppendLine("    $Framework = 'Standard'");
        sb.AppendLine("    $FrameworkNet = 'Standard'");
        sb.AppendLine("} elseif ($Core -and $Default) {");
        sb.AppendLine("    $Framework = 'Core'");
        sb.AppendLine("    $FrameworkNet = 'Default'");
        sb.AppendLine("} elseif ($Standard -and $Default) {");
        sb.AppendLine("    $Framework = 'Standard'");
        sb.AppendLine("    $FrameworkNet = 'Default'");
        sb.AppendLine("} elseif ($Standard) {");
        sb.AppendLine("    $Framework = 'Standard'");
        sb.AppendLine("    $FrameworkNet = 'Standard'");
        sb.AppendLine("} elseif ($Core) {");
        sb.AppendLine("    $Framework = 'Core'");
        sb.AppendLine("    $FrameworkNet = ''");
        sb.AppendLine("} elseif ($Default) {");
        sb.AppendLine("    $Framework = ''");
        sb.AppendLine("    $FrameworkNet = 'Default'");
        sb.AppendLine("} else {");
        sb.AppendLine("    #Write-Error -Message 'No assemblies found'");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("if ($PSEdition -eq 'Core') {");
        sb.AppendLine("    $LibFolder = $Framework");
        sb.AppendLine("} else {");
        sb.AppendLine("    $LibFolder = $FrameworkNet");
        sb.AppendLine("}");
        sb.AppendLine();
        sb.AppendLine("$LibrariesToLoad = $LibrariesByFolder[$LibFolder]");
        sb.AppendLine("if ($null -eq $LibrariesToLoad) { $LibrariesToLoad = @() }");
        sb.AppendLine("foreach ($L in $LibrariesToLoad) {");
        sb.AppendLine("    try {");
        sb.AppendLine("        Add-Type -Path $PSScriptRoot\\$L -ErrorAction Stop");
        sb.AppendLine("    } catch {");
        sb.AppendLine("        if ($_.Exception.Message -like '*Assembly with same name is already loaded*') {");
        sb.AppendLine("            Write-Warning -Message \"Assembly with same name is already loaded. Ignoring '$L'.\"");
        sb.AppendLine("        } else {");
        sb.AppendLine("            throw $_");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static List<string> EnumerateDllRelativePaths(string libRoot, string? folderName, IReadOnlyList<string> exportAssemblyFileNames)
    {
        var list = new List<string>();

        var dir = string.IsNullOrWhiteSpace(folderName) ? libRoot : Path.Combine(libRoot, folderName);
        if (!Directory.Exists(dir)) return list;

        string[] dllFiles;
        try
        {
            dllFiles = Directory.EnumerateFiles(dir, "*.dll", SearchOption.TopDirectoryOnly)
                .Select(Path.GetFileName)
                .Where(n => !string.IsNullOrWhiteSpace(n))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToArray()!;
        }
        catch
        {
            return list;
        }

        var exportFirst = new HashSet<string>(exportAssemblyFileNames ?? Array.Empty<string>(), StringComparer.OrdinalIgnoreCase);
        foreach (var name in exportAssemblyFileNames ?? Array.Empty<string>())
        {
            if (string.IsNullOrWhiteSpace(name)) continue;
            if (!dllFiles.Contains(name, StringComparer.OrdinalIgnoreCase)) continue;
            list.Add(RelativeLibPath(folderName, name));
        }

        foreach (var name in dllFiles.OrderBy(n => n, StringComparer.OrdinalIgnoreCase))
        {
            if (exportFirst.Contains(name)) continue;
            list.Add(RelativeLibPath(folderName, name));
        }

        return list;

        static string RelativeLibPath(string? folder, string fileName)
        {
            var parts = new List<string> { "Lib" };
            if (!string.IsNullOrWhiteSpace(folder)) parts.Add(folder);
            parts.Add(fileName);
            return string.Join("\\", parts);
        }
    }

    private static string EscapePsSingleQuoted(string value)
        => (value ?? string.Empty).Replace("'", "''");

    private static string BuildBootstrapperPsm1(string moduleName, string libraryName, ExportSet exports, bool includeBinaryLoader)
    {
        var sb = new StringBuilder(8192);
        sb.AppendLine($"# {moduleName} bootstrapper");
        sb.AppendLine("# Auto-generated by PowerForge. Do not edit.");
        sb.AppendLine();

        if (includeBinaryLoader)
        {
            sb.AppendLine("# Get library name, from the PSM1 file name");
            sb.AppendLine($"$LibraryName = '{EscapePsSingleQuoted(libraryName)}'");
            sb.AppendLine("$Library = \"$LibraryName.dll\"");
            sb.AppendLine("$Class = \"$LibraryName.Initialize\"");
            sb.AppendLine();

            sb.AppendLine("$AssemblyFolders = Get-ChildItem -Path $PSScriptRoot\\Lib -Directory -ErrorAction SilentlyContinue");
            sb.AppendLine();
            sb.AppendLine("$Default = $false");
            sb.AppendLine("$Core = $false");
            sb.AppendLine("$Standard = $false");
            sb.AppendLine("foreach ($A in $AssemblyFolders.Name) {");
            sb.AppendLine("    if ($A -eq 'Default') {");
            sb.AppendLine("        $Default = $true");
            sb.AppendLine("    } elseif ($A -eq 'Core') {");
            sb.AppendLine("        $Core = $true");
            sb.AppendLine("    } elseif ($A -eq 'Standard') {");
            sb.AppendLine("        $Standard = $true");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine("if ($Standard -and $Core -and $Default) {");
            sb.AppendLine("    $FrameworkNet = 'Default'");
            sb.AppendLine("    $Framework = 'Standard'");
            sb.AppendLine("} elseif ($Standard -and $Core) {");
            sb.AppendLine("    $Framework = 'Standard'");
            sb.AppendLine("    $FrameworkNet = 'Standard'");
            sb.AppendLine("} elseif ($Core -and $Default) {");
            sb.AppendLine("    $Framework = 'Core'");
            sb.AppendLine("    $FrameworkNet = 'Default'");
            sb.AppendLine("} elseif ($Standard -and $Default) {");
            sb.AppendLine("    $Framework = 'Standard'");
            sb.AppendLine("    $FrameworkNet = 'Default'");
            sb.AppendLine("} elseif ($Standard) {");
            sb.AppendLine("    $Framework = 'Standard'");
            sb.AppendLine("    $FrameworkNet = 'Standard'");
            sb.AppendLine("} elseif ($Core) {");
            sb.AppendLine("    $Framework = 'Core'");
            sb.AppendLine("    $FrameworkNet = ''");
            sb.AppendLine("} elseif ($Default) {");
            sb.AppendLine("    $Framework = ''");
            sb.AppendLine("    $FrameworkNet = 'Default'");
            sb.AppendLine("} else {");
            sb.AppendLine("    Write-Error -Message 'No assemblies found'");
            sb.AppendLine("}");
            sb.AppendLine();
            sb.AppendLine("if ($PSEdition -eq 'Core') {");
            sb.AppendLine("    $LibFolder = $Framework");
            sb.AppendLine("} else {");
            sb.AppendLine("    $LibFolder = $FrameworkNet");
            sb.AppendLine("}");
            sb.AppendLine();

            sb.AppendLine("try {");
            sb.AppendLine("    $ImportModule = Get-Command -Name Import-Module -Module Microsoft.PowerShell.Core");
            sb.AppendLine();
            sb.AppendLine("    if (-not ($Class -as [type])) {");
            sb.AppendLine("        & $ImportModule ([IO.Path]::Combine($PSScriptRoot, 'Lib', $LibFolder, $Library)) -ErrorAction Stop");
            sb.AppendLine("    } else {");
            sb.AppendLine("        $Type = \"$Class\" -as [Type]");
            sb.AppendLine("        & $importModule -Force -Assembly ($Type.Assembly)");
            sb.AppendLine("    }");
            sb.AppendLine("} catch {");
            sb.AppendLine("    if ($ErrorActionPreference -eq 'Stop') {");
            sb.AppendLine("        throw");
            sb.AppendLine("    } else {");
            sb.AppendLine("        Write-Warning -Message \"Importing module $Library failed. Fix errors before continuing. Error: $($_.Exception.Message)\"");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            sb.AppendLine();

            sb.AppendLine("# Dot source all libraries by loading external file");
            sb.AppendLine($"$LibrariesScript = [IO.Path]::Combine($PSScriptRoot, '{EscapePsSingleQuoted(moduleName)}.Libraries.ps1')");
            sb.AppendLine("if (Test-Path -LiteralPath $LibrariesScript) {");
            sb.AppendLine("    . $LibrariesScript");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        sb.AppendLine("# Get public and private function definition files.");
        sb.AppendLine("$Public  = @(Get-ChildItem -Path ([IO.Path]::Combine($PSScriptRoot, 'Public', '*.ps1')) -ErrorAction SilentlyContinue -Recurse)");
        sb.AppendLine("$Private = @(Get-ChildItem -Path ([IO.Path]::Combine($PSScriptRoot, 'Private', '*.ps1')) -ErrorAction SilentlyContinue -Recurse)");
        sb.AppendLine("$Classes = @(Get-ChildItem -Path ([IO.Path]::Combine($PSScriptRoot, 'Classes', '*.ps1')) -ErrorAction SilentlyContinue -Recurse)");
        sb.AppendLine("$Enums   = @(Get-ChildItem -Path ([IO.Path]::Combine($PSScriptRoot, 'Enums', '*.ps1')) -ErrorAction SilentlyContinue -Recurse)");
        sb.AppendLine();

        sb.AppendLine("$FoundErrors = @(");
        sb.AppendLine("    # Dot source the files (Classes/Enums first).");
        sb.AppendLine("    foreach ($Import in @($Classes + $Enums + $Private + $Public)) {");
        sb.AppendLine("        try {");
        sb.AppendLine("            . $Import.Fullname");
        sb.AppendLine("        } catch {");
        sb.AppendLine("            Write-Error -Message \"Failed to import functions from $($import.Fullname): $_\"");
        sb.AppendLine("            $true");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine(")");
        sb.AppendLine();

        sb.AppendLine("if ($FoundErrors.Count -gt 0) {");
        sb.AppendLine("    $ModuleName = (Get-ChildItem -Path ([IO.Path]::Combine($PSScriptRoot, '*.psd1'))).BaseName");
        sb.AppendLine("    Write-Warning \"Importing module $ModuleName failed. Fix errors before continuing.\"");
        sb.AppendLine("    break");
        sb.AppendLine("}");
        sb.AppendLine();

        // Export lists (explicit, deterministic).
        sb.AppendLine("$FunctionsToExport = " + FormatPsStringList(exports.Functions));
        sb.AppendLine("$CmdletsToExport = " + FormatPsStringList(exports.Cmdlets));
        sb.AppendLine("$AliasesToExport = " + FormatPsStringList(exports.Aliases));
        sb.AppendLine("Export-ModuleMember -Function $FunctionsToExport -Alias $AliasesToExport -Cmdlet $CmdletsToExport");

        return sb.ToString();
    }

    private static string FormatPsStringList(IReadOnlyList<string>? values)
    {
        var list = (values ?? Array.Empty<string>())
            .Where(v => !string.IsNullOrWhiteSpace(v))
            .Select(v => v.Trim())
            .Distinct(StringComparer.OrdinalIgnoreCase)
            .ToArray();

        if (list.Length == 0) return "@()";
        if (list.Length == 1 && list[0] == "*") return "'*'";

        var sb = new StringBuilder();
        sb.Append("@(");
        for (var i = 0; i < list.Length; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append('\'').Append(EscapePsSingleQuoted(list[i])).Append('\'');
        }
        sb.Append(')');
        return sb.ToString();
    }
}
